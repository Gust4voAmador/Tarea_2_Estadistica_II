# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "x", ylab = "Distribución(x)", breaks = 200)
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
# Parámetros del algoritmo
L <- 1000  # Periodo quemado (burn in)
MCMC <- matrix(data = 0, nrow = nsim, ncol = 5)  # Cambiado para tener `nsim` filas
colnames(MCMC) <- c("x", "PIx", "PIy", "Fxy", "Salto")
x <- runif(1, 0, 10)  # Se inicia con un valor aleatorio para lambda
for (i in 1:nsim) {
y <- rgamma(1,3,2)  # Genera un valor aleatorio de funcion  gamma(3,2)
# Calcular las distribuciones
PIx <- vero(x)
PIy <- vero(y)
Kxy <- priori(x)
Kyx <- priori(y)
Rxy <- (PIy * Kyx) / (PIx * Kxy)
# Generar un número aleatorio uniforme
Fxy <- runif(1)
# Registrar los resultados en la matriz MCMC
MCMC[i, ] <- c(x, PIx, PIy, Fxy, 0)
# Verificar la aceptación
if (Fxy < Rxy) {
x <- y
lsalto <- 1
} else {
lsalto <- 0
}
MCMC[i, 5] <- lsalto
}
# Extraer las muestras después del periodo quemado
mcmc <- MCMC[(L + 1):nsim, "x"]
# Mostrar parte de la muestra obtenida
head(mcmc, 50)
# Definir el espacio de gráficos
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
# Histograma de la muestra observada original (para comparar)
hist(mx, freq = TRUE, main = "Histograma de la muestra observada",
xlab = "Número de siniestros", ylab = "Frecuencia", breaks = 8,
col = "lightgreen", border = "black")
# Definir el espacio de gráficos
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
# Definir el espacio de gráficos
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
mxdf <- data.frame(mx)
ggplot(mxdf, aes(x = mx)) +
geom_histogram(binwidth = 1, fill = "skyblue", color = "black") +
theme_minimal() +  # Estética preferida
labs(title = "Histograma de la muestra", x = "Valores", y = "Frecuencia")
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
# Definir el espacio de gráficos en una ventana de 2x2
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
# Histograma de la muestra original (`mx`)
hist(mx, freq = TRUE, main = "Histograma de la muestra original",
xlab = "Número de siniestros", ylab = "Frecuencia", breaks = 8,
col = "lightgreen", border = "black")
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
# Definir el espacio de gráficos en una ventana de 2x2
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
# Histograma de la muestra original (`mx`)
hist(mx, freq = TRUE, main = "Histograma de la muestra original",
xlab = "Número de siniestros", ylab = "Frecuencia", breaks = 6,
col = "lightgreen", border = "black")
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
# Definir el espacio de gráficos en una ventana de 2x2
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
# Histograma de la muestra original (`mx`)
hist(mx, freq = TRUE, main = "Histograma de la muestra original",
xlab = "Número de siniestros", ylab = "Frecuencia", breaks = 7,
col = "lightgreen", border = "black")
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
# Definir el espacio de gráficos en una ventana de 2x2
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
# Histograma de la muestra original (`mx`)
hist(mx, freq = TRUE, main = "Histograma de la muestra original",
xlab = "Número de siniestros", ylab = "Frecuencia", breaks = 8,
col = "lightgreen", border = "black")
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
#La muestra de los siniestros observados
mx <- c(4,2,5,6,3,4,7,5,6,4)
# Crear el histograma
mxdf <- data.frame(mx)
ggplot(mxdf, aes(x = mx)) +
geom_histogram(binwidth = 0.5, fill = "skyblue", color = "black") +
theme_minimal() +  # Estética preferida
labs(title = "Histograma de la muestra", x = "Valores", y = "Frecuencia")
# Cargar la librería ggplot2
library(ggplot2)
# Definir el espacio de gráficos en una ventana de 2x2
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
# Histograma de la muestra original (`mx`) usando ggplot2
mxdf <- data.frame(mx)
p <- ggplot(mxdf, aes(x = mx)) +
geom_histogram(binwidth = 0.5, fill = "lightgreen", color = "black") +
theme_minimal() +  # Estética preferida
labs(title = "Histograma de la muestra original", x = "Número de siniestros", y = "Frecuencia")
print(p)  # Mostrar el histograma con ggplot2
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
#Grafico convergencia de la media
m=nsim-L
acumulado<-cumsum(mcmc)/(1:m)
plot(1:m,acumulado,col="blue",type="l",ylab="promedio",xlab="Iteraciones")
cat("Tasa de aceptacion \n",
"NumeroSaltos/TotalIteraciones :" , mean(MCMC[,"Salto"]) ,"\n")
print(cat("Media/lambda: ", lambda))
cat("Tasa de aceptacion \n",
"NumeroSaltos/TotalIteraciones :" , mean(MCMC[,"Salto"]) ,"\n")
print(cat("Media/lambda: ", lambda))
cat("Tasa de aceptacion \n",
"NumeroSaltos/TotalIteraciones :" , mean(MCMC[,"Salto"]) ,"\n")
print(cat("Media/lambda: ", lambda))
# Cargar la librería ggplot2
library(ggplot2)
# Definir el espacio de gráficos en una ventana de 2x2
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
print(lambda)
# Histograma de la muestra original (`mx`) usando ggplot2
mxdf <- data.frame(mx)
p <- ggplot(mxdf, aes(x = mx)) +
geom_histogram(binwidth = 0.5, fill = "lightgreen", color = "black") +
theme_minimal() +  # Estética preferida
labs(title = "Histograma de la muestra original", x = "Número de siniestros", y = "Frecuencia")
print(p)  # Mostrar el histograma con ggplot2
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
print(cat("Media/lambda: ", lambda))
print(cat("Media/lambda: " lambda))
print(cat("Media/lambda: ", lambda, "\n"))
print(lambda)
print("Estimacion de la media/lambda:")
print(lambda)
cat("Estimacion de la media/lambda:")
print(lambda)
cat("Estimacion de la media/lambda:", lambda)
print(lambda)
cat("Estimacion de la media/lambda:", lambda)
set.seed(54321)
nsim <- 20^4 #numero de simulaciones
# Distribución de verosimilitud
vero <- function(lambda) {prod(dpois(mx, lambda))}
# Distribución priori
priori <- function(lambda) {
dgamma(lambda, shape = 3, rate = 2)
}
# Parámetros del algoritmo
L <- 1000  # Periodo quemado (burn in)
MCMC <- matrix(data = 0, nrow = nsim, ncol = 5)  # Cambiado para tener `nsim` filas
colnames(MCMC) <- c("x", "PIx", "PIy", "Fxy", "Salto")
x <- runif(1, 0, 10)  # Se inicia con un valor aleatorio para lambda
for (i in 1:nsim) {
y <- rgamma(1,3,2)  # Genera un valor aleatorio de funcion  gamma(3,2)
# Calcular las distribuciones
PIx <- vero(x)
PIy <- vero(y)
Kxy <- priori(x)
Kyx <- priori(y)
Rxy <- (PIy * Kyx) / (PIx * Kxy)
# Generar un número aleatorio uniforme
Fxy <- runif(1)
# Registrar los resultados en la matriz MCMC
MCMC[i, ] <- c(x, PIx, PIy, Fxy, 0)
# Verificar la aceptación
if (Fxy < Rxy) {
x <- y
lsalto <- 1
} else {
lsalto <- 0
}
MCMC[i, 5] <- lsalto
}
# Extraer las muestras después del periodo quemado
mcmc <- MCMC[(L + 1):nsim, "x"]
# Mostrar parte de la muestra obtenida
head(mcmc, 50)
# Cargar la librería ggplot2
library(ggplot2)
# Definir el espacio de gráficos en una ventana de 2x2
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
# Histograma de la muestra original (`mx`) usando ggplot2
mxdf <- data.frame(mx)
p <- ggplot(mxdf, aes(x = mx)) +
geom_histogram(binwidth = 0.5, fill = "lightgreen", color = "black") +
theme_minimal() +  # Estética preferida
labs(title = "Histograma de la muestra original", x = "Número de siniestros", y = "Frecuencia")
print(p)  # Mostrar el histograma con ggplot2
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
set.seed(54321)
nsim <- 10^4 #numero de simulaciones
# Distribución de verosimilitud
vero <- function(lambda) {prod(dpois(mx, lambda))}
# Distribución priori
priori <- function(lambda) {
dgamma(lambda, shape = 3, rate = 2)
}
# Parámetros del algoritmo
L <- 1000  # Periodo quemado (burn in)
MCMC <- matrix(data = 0, nrow = nsim, ncol = 5)  # Cambiado para tener `nsim` filas
colnames(MCMC) <- c("x", "PIx", "PIy", "Fxy", "Salto")
x <- runif(1, 0, 10)  # Se inicia con un valor aleatorio para lambda
for (i in 1:nsim) {
y <- rgamma(1,3,2)  # Genera un valor aleatorio de funcion  gamma(3,2)
# Calcular las distribuciones
PIx <- vero(x)
PIy <- vero(y)
Kxy <- priori(x)
Kyx <- priori(y)
Rxy <- (PIy * Kyx) / (PIx * Kxy)
# Generar un número aleatorio uniforme
Fxy <- runif(1)
# Registrar los resultados en la matriz MCMC
MCMC[i, ] <- c(x, PIx, PIy, Fxy, 0)
# Verificar la aceptación
if (Fxy < Rxy) {
x <- y
lsalto <- 1
} else {
lsalto <- 0
}
MCMC[i, 5] <- lsalto
}
# Extraer las muestras después del periodo quemado
mcmc <- MCMC[(L + 1):nsim, "x"]
# Mostrar parte de la muestra obtenida
head(mcmc, 50)
# Cargar la librería ggplot2
library(ggplot2)
# Definir el espacio de gráficos en una ventana de 2x2
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
# Histograma de la muestra original (`mx`) usando ggplot2
mxdf <- data.frame(mx)
p <- ggplot(mxdf, aes(x = mx)) +
geom_histogram(binwidth = 0.5, fill = "lightgreen", color = "black") +
theme_minimal() +  # Estética preferida
labs(title = "Histograma de la muestra original", x = "Número de siniestros", y = "Frecuencia")
print(p)  # Mostrar el histograma con ggplot2
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
library(ggplot2)
#La muestra de los siniestros observados
mx <- c(4,2,5,6,3,4,7,5,6,4)
# Crear el histograma
mxdf <- data.frame(mx)
ggplot(mxdf, aes(x = mx)) +
geom_histogram(binwidth = 0.5, fill = "skyblue", color = "black") +
theme_minimal() +  # Estética preferida
labs(title = "Histograma de la muestra", x = "Valores", y = "Frecuencia")
set.seed(54321)
nsim <- 10^4 #numero de simulaciones
# Distribución de verosimilitud
vero <- function(lambda) {prod(dpois(mx, lambda))}
# Distribución priori
alpha <- 3
beta <- 2
priori <- function(lambda) {
dgamma(lambda, alpha, 1/beta)
}
# Parámetros del algoritmo
L <- 1000  # Periodo quemado (burn in)
MCMC <- matrix(data = 0, nrow = nsim, ncol = 5)  # Cambiado para tener `nsim` filas
colnames(MCMC) <- c("x", "PIx", "PIy", "Fxy", "Salto")
x <- runif(1, 0, 10)  # Se inicia con un valor aleatorio para lambda
for (i in 1:nsim) {
y <- rgamma(1,alpha, 1/beta)  # Genera un valor aleatorio de funcion  gamma(3,2)
# Calcular las distribuciones
PIx <- vero(x)
PIy <- vero(y)
Kxy <- priori(x)
Kyx <- priori(y)
Rxy <- (PIy * Kyx) / (PIx * Kxy)
# Generar un número aleatorio uniforme
Fxy <- runif(1)
# Registrar los resultados en la matriz MCMC
MCMC[i, ] <- c(x, PIx, PIy, Fxy, 0)
# Verificar la aceptación
if (Fxy < Rxy) {
x <- y
lsalto <- 1
} else {
lsalto <- 0
}
MCMC[i, 5] <- lsalto
}
# Extraer las muestras después del periodo quemado
mcmc <- MCMC[(L + 1):nsim, "x"]
# Mostrar parte de la muestra obtenida
head(mcmc, 50)
# Cargar la librería ggplot2
library(ggplot2)
# Definir el espacio de gráficos en una ventana de 2x2
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
# Histograma de la muestra original (`mx`) usando ggplot2
mxdf <- data.frame(mx)
p <- ggplot(mxdf, aes(x = mx)) +
geom_histogram(binwidth = 0.5, fill = "lightgreen", color = "black") +
theme_minimal() +  # Estética preferida
labs(title = "Histograma de la muestra original", x = "Número de siniestros", y = "Frecuencia")
print(p)  # Mostrar el histograma con ggplot2
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
set.seed(54321)
nsim <- 10^4 #numero de simulaciones
# Distribución de verosimilitud
vero <- function(lambda) {prod(dpois(mx, lambda))}
# Distribución priori
alpha <- 3
beta <- 2
priori <- function(lambda) {
dgamma(lambda, alpha, 1/beta)
}
# Parámetros del algoritmo
L <- 1000  # Periodo quemado (burn in)
MCMC <- matrix(data = 0, nrow = nsim, ncol = 5)  # Cambiado para tener `nsim` filas
colnames(MCMC) <- c("x", "PIx", "PIy", "Fxy", "Salto")
x <- runif(1, 0, 10)  # Se inicia con un valor aleatorio para lambda
for (i in 1:nsim) {
y <- rgamma(1,alpha, 1/beta)  # Genera un valor aleatorio de funcion  gamma(3,2)
# Calcular las distribuciones
PIx <- vero(x)
PIy <- vero(y)
Kxy <- priori(x)
Kyx <- priori(y)
Rxy <- (PIy * Kyx) / (PIx * Kxy)
# Generar un número aleatorio uniforme
Fxy <- runif(1)
# Registrar los resultados en la matriz MCMC
MCMC[i, ] <- c(x, PIx, PIy, Fxy, 0)
# Verificar la aceptación
if (Fxy < Rxy) {
x <- y
lsalto <- 1
} else {
lsalto <- 0
}
MCMC[i, 5] <- lsalto
}
# Extraer las muestras después del periodo quemado
mcmc <- MCMC[(L + 1):nsim, "x"]
# Mostrar parte de la muestra obtenida
head(mcmc, 50)
# Cargar la librería ggplot2
library(ggplot2)
# Definir el espacio de gráficos en una ventana de 2x2
par(mfrow = c(2, 2))
# Calcular lambda a partir de la media de la muestra MCMC
lambda <- mean(mcmc)
# Histograma de la muestra original (`mx`) usando ggplot2
mxdf <- data.frame(mx)
p <- ggplot(mxdf, aes(x = mx)) +
geom_histogram(binwidth = 0.5, fill = "lightgreen", color = "black") +
theme_minimal() +  # Estética preferida
labs(title = "Histograma de la muestra original", x = "Número de siniestros", y = "Frecuencia")
print(p)  # Mostrar el histograma con ggplot2
# Histograma de la muestra MCMC
hist(mcmc, freq = FALSE, main = "Distribución de muestra MCMC",
xlab = "Valores de Lambda", ylab = "Densidad", breaks = 50,
col = "skyblue", border = "black")
abline(v = lambda, col = 'violet', lwd = 3)
# Traceplot de la muestra MCMC
plot(mcmc, type = "l", xlab = "Iteraciones", ylab = "Valor de Lambda",
main = "Traceplot de muestra MCMC")
abline(h = lambda, col = 'violet', lwd = 3)
# Gráfico de autocorrelación
acf(mcmc, main = "Autocorrelación de muestra MCMC")
